<!doctype html><html lang=en-gb data-theme><head><meta charset=utf-8><meta name=HandheldFriendly content="True"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer-when-downgrade"><title>Getting rustc to use AVX2 SIMD - alex posts</title>
<meta name=description content="SIMD roughly means CPU instructions that do multiple things at once. Making use of them can make algorithms faster. The rust compiler actually uses them automatically, but it doesn&rsquo;t for newer SIMD instructions like SSE4.2 & AVX2.
SIMD Feature Coverage SSE2 100% SSE4.2 99.1% AVX2 89.2% AVX512F 8.73% Steam survey October 2022
Rustc can&rsquo;t use them by default because not every CPU will work with them. But these days most CPUs do support these newer instructions and so certain tasks can be a lot faster for a lot of people."><link rel=icon type=image/x-icon href=https://alexheretic.github.io/favicon.ico><link rel=apple-touch-icon-precomposed href=https://alexheretic.github.io/favicon.png><style>body{visibility:hidden;opacity:0}</style><noscript><style>body{visibility:visible;opacity:1}</style></noscript><link rel=stylesheet href=https://alexheretic.github.io/css/style.min.cb6f57b286a1f09223c013270b2706d7691a837dab35f1e96726d8029b8222b7.css integrity="sha256-y29Xsoah8JIjwBMnCycG12kag32rNfHpZybYApuCIrc="><script src=https://alexheretic.github.io/js/script.min.74bf1a3fcf1af396efa4acf3e660e876b61a2153ab9cbe1893ac24ea6d4f94ee.js type=text/javascript integrity="sha256-dL8aP88a85bvpKzz5mDodrYaIVOrnL4Yk6wk6m1PlO4="></script><meta property="og:url" content="https://alexheretic.github.io/posts/auto-avx2/"><meta property="og:site_name" content="alex posts"><meta property="og:title" content="Getting rustc to use AVX2 SIMD"><meta property="og:description" content="SIMD roughly means CPU instructions that do multiple things at once. Making use of them can make algorithms faster. The rust compiler actually uses them automatically, but it doesn’t for newer SIMD instructions like SSE4.2 & AVX2.
SIMD Feature Coverage SSE2 100% SSE4.2 99.1% AVX2 89.2% AVX512F 8.73% Steam survey October 2022
Rustc can’t use them by default because not every CPU will work with them. But these days most CPUs do support these newer instructions and so certain tasks can be a lot faster for a lot of people."><meta property="og:locale" content="en_gb"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-12T00:00:00+00:00"><meta property="article:modified_time" content="2022-11-12T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Getting rustc to use AVX2 SIMD"><meta name=twitter:description content="SIMD roughly means CPU instructions that do multiple things at once. Making use of them can make algorithms faster. The rust compiler actually uses them automatically, but it doesn’t for newer SIMD instructions like SSE4.2 & AVX2.
SIMD Feature Coverage SSE2 100% SSE4.2 99.1% AVX2 89.2% AVX512F 8.73% Steam survey October 2022
Rustc can’t use them by default because not every CPU will work with them. But these days most CPUs do support these newer instructions and so certain tasks can be a lot faster for a lot of people."></head><body><a class=skip-main href=#main>Skip to main content</a><div class=container><header class=common-header><div class=header-top><div class=header-top-left><h1 class=site-title><a href=/>alex posts</a></h1><ul class=social-icons><li><a href=https://github.com/alexheretic title=Github rel=me><span class=inline-svg><svg viewBox="0 0 496 512"><path fill="currentcolor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span></a></li><li><a href=https://fosstodon.org/@alexbigab title=Mastodon rel=me><span class=inline-svg><svg viewBox="0 0 448 512"><path fill="currentcolor" d="M433 179.11c0-97.2-63.71-125.7-63.71-125.7-62.52-28.7-228.56-28.4-290.48.0.0.0-63.72 28.5-63.72 125.7.0 115.7-6.6 259.4 105.63 289.1 40.51 10.7 75.32 13 103.33 11.4 50.81-2.8 79.32-18.1 79.32-18.1l-1.7-36.9s-36.31 11.4-77.12 10.1c-40.41-1.4-83-4.4-89.63-54a102.54 102.54.0 01-.9-13.9c85.63 20.9 158.65 9.1 178.75 6.7 56.12-6.7 105-41.3 111.23-72.9 9.8-49.8 9-121.5 9-121.5zm-75.12 125.2h-46.63v-114.2c0-49.7-64-51.6-64 6.9v62.5h-46.33V197c0-58.5-64-56.6-64-6.9v114.2H90.19c0-122.1-5.2-147.9 18.41-175 25.9-28.9 79.82-30.8 103.83 6.1l11.6 19.5 11.6-19.5c24.11-37.1 78.12-34.8 103.83-6.1 23.71 27.3 18.4 53 18.4 175z"/></svg></span></a></li><li><a href=https://alexheretic.github.io/index.xml title=RSS rel=me><span class=inline-svg><svg viewBox="0 0 448 512"><path fill="currentcolor" d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328.0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765.0 183.105.0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686.0 38.981.0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"/></svg></span></a></li></ul></div><div class=header-top-right><div class=theme-switcher><span class=inline-svg><svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 290 290"><path fill="currentcolor" d="M142.959.0C64.131.0.0 64.132.0 142.96s64.131 142.959 142.959 142.959 142.96-64.131 142.96-142.959C285.919 64.132 221.787.0 142.959.0zm0 260.919V142.96 25c65.043.0 117.96 52.917 117.96 117.96.0 65.043-52.917 117.959-117.96 117.959z"/></svg></span></div><script>const STORAGE_KEY="user-color-scheme",defaultTheme="dark";let currentTheme,switchButton,autoDefinedScheme=window.matchMedia("(prefers-color-scheme: dark)");const autoChangeScheme=e=>{currentTheme=e.matches?"dark":"light",document.documentElement.setAttribute("data-theme",currentTheme)};document.addEventListener("DOMContentLoaded",function(){switchButton=document.querySelector(".theme-switcher"),currentTheme=detectCurrentScheme(),currentTheme=="dark"&&document.documentElement.setAttribute("data-theme","dark"),currentTheme=="auto"&&(autoChangeScheme(autoDefinedScheme),autoDefinedScheme.addListener(autoChangeScheme)),switchButton&&switchButton.addEventListener("click",switchTheme,!1),showContent()});function detectCurrentScheme(){return localStorage!==null&&localStorage.getItem(STORAGE_KEY)?localStorage.getItem(STORAGE_KEY):defaultTheme?defaultTheme:window.matchMedia?window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light":"light"}function switchTheme(){currentTheme=="dark"?(localStorage!==null&&localStorage.setItem(STORAGE_KEY,"light"),document.documentElement.setAttribute("data-theme","light"),currentTheme="light"):(localStorage!==null&&localStorage.setItem(STORAGE_KEY,"dark"),document.documentElement.setAttribute("data-theme","dark"),currentTheme="dark")}function showContent(){document.body.style.visibility="visible",document.body.style.opacity=1}</script></div></div><nav></nav></header><main id=main tabindex=-1><article class="post h-entry"><div class=post-header><header><h1 class="p-name post-title">Getting rustc to use AVX2 SIMD</h1></header></div><div class="content e-content"><p>SIMD roughly means CPU instructions that do multiple things at once. Making use of them can make algorithms faster. The rust compiler actually uses them automatically, but it <em>doesn&rsquo;t</em> for newer SIMD instructions like SSE4.2 & AVX2.</p><table><thead><tr><th>SIMD Feature</th><th>Coverage</th></tr></thead><tbody><tr><td>SSE2</td><td>100%</td></tr><tr><td>SSE4.2</td><td>99.1%</td></tr><tr><td>AVX2</td><td>89.2%</td></tr><tr><td>AVX512F</td><td>8.73%</td></tr></tbody></table><p><em>Steam survey October 2022</em></p><p>Rustc can&rsquo;t use them by default because not every CPU will work with them. But these days most CPUs <em>do</em> support these newer instructions and so certain tasks can be a <strong>lot</strong> faster for a lot of people.</p><h2 id=what-code-can-be-optimised>What code can be optimised?
<span><a href=#what-code-can-be-optimised><svg viewBox="0 0 28 23" height="100%" width="19"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h2><p>Without a good understanding of SIMD it can be hard to know what kind of tasks should benefit, but at a high level what I look for is <strong>loops with maths in the middle</strong>. If we&rsquo;re looping over a load of data and doing maths there&rsquo;s a chance this could be vectorized, which means the data gets packed together and requires lower total number of SIMD instructions to reach the same result.</p><p>For example my crate <a href=https://github.com/alexheretic/ab-glyph/tree/main/rasterizer>ab_glyph_rasterizer</a> rasterization logic I know is an expensive operation. This involves drawing a font glyph&rsquo;s outline onto a 2d coverage grid. There are some loops with maths in the middle there so <em>can rustc make it faster on my CPU?</em></p><h2 id=benchmarking>Benchmarking
<span><a href=#benchmarking><svg viewBox="0 0 28 23" height="100%" width="19"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h2><p>My first step to optimising code is to write a benchmark. Optimising is <em>hard</em>. A benchmark can tell you if an optimisation has actually worked. This is important as optimisations often bloat the code and make it less readable in the name of performance, so you really should be proving that the performance has improved!</p><p>I already had some benches for <em>ab_glyph_rasterizer</em> so lets fire one up using default rustc settings.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ cargo bench --bench rasterize rasterize_outline_ttf_biohazard -- --save-baseline default
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>rasterize_outline_ttf_biohazard
</span></span><span style=display:flex><span>        time:   <span style=color:#f92672>[</span>18.383 µs 18.385 µs 18.388 µs<span style=color:#f92672>]</span>
</span></span></code></pre></div><p><img src=biohazard-180px.png alt title="biohazard glyph"></p><p>So rasterizing a 294x269px biohazard glyph on my 5800x takes <strong>~18.4µs</strong>.</p><blockquote><p>Aside: Writing benchmarks is also hard. I ran mine 4 times and got 19.3µs, 18.8µs, 18.5µs, 18.4µs so I&rsquo;ll need to take the noise into account before I start celebrating a win that was just noise.</p></blockquote><p>The cool thing about having a benchmark is we can start investigating if SIMD is going to help us <strong>without writing any clever code</strong>.</p><h2 id=benching-with-target-cpunative>Benching with target-cpu=native
<span><a href=#benching-with-target-cpunative><svg viewBox="0 0 28 23" height="100%" width="19"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h2><p>I can tell rustc to use all the SIMD instructions my CPU supports and benchmark again.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ RUSTFLAGS<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;-C target-cpu=native&#39;</span> cargo bench --bench rasterize rasterize_outline_ttf_biohazard -- --baseline default
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>rasterize_outline_ttf_biohazard
</span></span><span style=display:flex><span>        time:   <span style=color:#f92672>[</span>14.224 µs 14.242 µs 14.264 µs<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>        change: <span style=color:#f92672>[</span>-22.094% -21.920% -21.752%<span style=color:#f92672>]</span> <span style=color:#f92672>(</span>p <span style=color:#f92672>=</span> 0.00 &lt; 0.05<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>We can draw the same glyph in <strong>~14.2µs</strong> now. A nice speedup for no extra code! This is an indication that the code we&rsquo;re benchmarking could benefit from auto-vectorization.</p><p>We can also try to generalize a bit. Lets try just enabling AVX2 since I know that&rsquo;s one of the newest SIMD features my CPU supports.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ RUSTFLAGS<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;-C target-feature=+avx2&#39;</span> cargo bench --bench rasterize rasterize_outline_ttf_biohazard -- --baseline default
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>rasterize_outline_ttf_biohazard
</span></span><span style=display:flex><span>        time:   <span style=color:#f92672>[</span>14.412 µs 14.419 µs 14.427 µs<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>        change: <span style=color:#f92672>[</span>-21.843% -21.726% -21.613%<span style=color:#f92672>]</span> <span style=color:#f92672>(</span>p <span style=color:#f92672>=</span> 0.00 &lt; 0.05<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>So we get pretty much the same benefit by simply enabling AVX2.</p><p>But we&rsquo;re not done. If I compile, for example, my game with <code>RUSTFLAGS='-C target-feature=+avx2'</code> it will be faster. But it will also stop working for ~11% of my game&rsquo;s players, which is obviously not ok. We want to enable AVX2 for CPUs that support it and use the old code for everyone else.</p><h2 id=targeting-the-functions-to-auto-vectorize>Targeting the functions to auto-vectorize
<span><a href=#targeting-the-functions-to-auto-vectorize><svg viewBox="0 0 28 23" height="100%" width="19"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h2><p>As a first step to runtime enabling AVX2 I started looking for particular functions that I&rsquo;d like to auto-vectorize. I found <a href=https://github.com/alexheretic/ab-glyph/blob/65064cf8d21affe27cce0e23535bc9a8cb02e8a4/rasterizer/src/raster.rs#L97><code>Rasterizer::draw_line</code></a> which is the core fn for this task and it has loop with tons of maths inside.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Rasterizer {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>draw_line</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, p0: <span style=color:#a6e22e>Point</span>, p1: <span style=color:#a6e22e>Point</span>) { 
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* maths-loops */</span> 
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We can instruct rustc to compile this using AVX2.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[target_feature(enable = </span><span style=color:#e6db74>&#34;avx2&#34;</span><span style=color:#75715e>)]</span> <span style=color:#75715e>// doesn&#39;t compile!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>draw_line</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, p0: <span style=color:#a6e22e>Point</span>, p1: <span style=color:#a6e22e>Point</span>) {
</span></span></code></pre></div><p>This doesn&rsquo;t work because:</p><blockquote><p><code>#[target_feature(..)]</code> can only be applied to <code>unsafe</code> functions</p></blockquote><p>Actually that makes sense, after all it won&rsquo;t work on all CPUs. Lets just do it anyway.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>draw_line</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, p0: <span style=color:#a6e22e>Point</span>, p1: <span style=color:#a6e22e>Point</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsafe</span> { self.draw_line_avx2(p0, p1) }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[target_feature(enable = </span><span style=color:#e6db74>&#34;avx2&#34;</span><span style=color:#75715e>)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>draw_line_avx2</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, p0: <span style=color:#a6e22e>Point</span>, p1: <span style=color:#a6e22e>Point</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* maths-loops */</span> 
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now we&rsquo;ve enabled AVX2 for this function we can bench again without any RUSTFLAGS.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ cargo bench --bench rasterize rasterize_outline_ttf_biohazard -- --baseline default
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>rasterize_outline_ttf_biohazard
</span></span><span style=display:flex><span>        time:   <span style=color:#f92672>[</span>14.273 µs 14.276 µs 14.280 µs<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>        change: <span style=color:#f92672>[</span>-22.566% -22.456% -22.352%<span style=color:#f92672>]</span> <span style=color:#f92672>(</span>p <span style=color:#f92672>=</span> 0.00 &lt; 0.05<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>So indeed this function is the place to be SIMD-ing! We&rsquo;re still not there yet though since the change <em>still</em> breaks any non-AVX2 CPU.</p><h2 id=runtime-detection>Runtime detection
<span><a href=#runtime-detection><svg viewBox="0 0 28 23" height="100%" width="19"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h2><p>We could wrap this optimisation in a compile time feature. But it isn&rsquo;t usually very useful to do so. All usage of this dependency would have to wire up the feature and ultimately something like my game would need a single binary to work for many different CPU feature levels.</p><p>What we want is runtime detection. We can do that with <strong><a href=https://doc.rust-lang.org/std/macro.is_x86_feature_detected.html>std::is_x86_feature_detected</a></strong>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>draw_line</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, p0: <span style=color:#a6e22e>Point</span>, p1: <span style=color:#a6e22e>Point</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> is_x86_feature_detected!(<span style=color:#e6db74>&#34;avx2&#34;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsafe</span> { self.draw_line_avx2(p0, p1) }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        self.draw_line_scalar(p0, p1)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[target_feature(enable = </span><span style=color:#e6db74>&#34;avx2&#34;</span><span style=color:#75715e>)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>draw_line_avx2</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, p0: <span style=color:#a6e22e>Point</span>, p1: <span style=color:#a6e22e>Point</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* maths-loops */</span> 
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>draw_line_scalar</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, p0: <span style=color:#a6e22e>Point</span>, p1: <span style=color:#a6e22e>Point</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* the same maths-loops */</span> 
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now we&rsquo;re actually getting somewhere. Our code is actually safe so should work everywhere.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ cargo bench --bench rasterize rasterize_outline_ttf_biohazard -- --baseline default
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>rasterize_outline_ttf_biohazard
</span></span><span style=display:flex><span>        time:   <span style=color:#f92672>[</span>14.415 µs 14.419 µs 14.424 µs<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>        change: <span style=color:#f92672>[</span>-21.784% -21.665% -21.553%<span style=color:#f92672>]</span> <span style=color:#f92672>(</span>p <span style=color:#f92672>=</span> 0.00 &lt; 0.05<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Benching the code shows we&rsquo;re still getting the benefit.</p><h2 id=inlining>Inlining
<span><a href=#inlining><svg viewBox="0 0 28 23" height="100%" width="19"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h2><p>One issue with this version however is the bulk of my code, the loops, has been duplicated. So there&rsquo;s a bunch more code. We can fix this fairly easily with inlining.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>draw_line</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, p0: <span style=color:#a6e22e>Point</span>, p1: <span style=color:#a6e22e>Point</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> is_x86_feature_detected!(<span style=color:#e6db74>&#34;avx2&#34;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsafe</span> { self.draw_line_avx2(p0, p1) }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        self.draw_line_scalar(p0, p1)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[target_feature(enable = </span><span style=color:#e6db74>&#34;avx2&#34;</span><span style=color:#75715e>)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>draw_line_avx2</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, p0: <span style=color:#a6e22e>Point</span>, p1: <span style=color:#a6e22e>Point</span>) {
</span></span><span style=display:flex><span>    self.draw_line_scalar(p0, p1)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[inline(always)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>draw_line_scalar</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, p0: <span style=color:#a6e22e>Point</span>, p1: <span style=color:#a6e22e>Point</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* maths-loops */</span> 
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This did look kinda funny to me the first time. The implementation of <code>draw_line_avx2</code> is just calling <code>draw_line_scalar</code>. It looks a bit pointless from a logical point of view, but this is for the compiler rather than for us. Note <code>#[inline(always)]</code> is important because we need rustc to duplicate the compilation to get 2 compiled versions of draw-line, one with AVX2 instructions.</p><p>Now we have a legit optimisation to the code. Not too much extra code, just some feature detection wiring and inlining.</p><h2 id=optimising-feature-detection--sse42>Optimising feature detection & SSE4.2
<span><a href=#optimising-feature-detection--sse42><svg viewBox="0 0 28 23" height="100%" width="19"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h2><p>An issue you may have spotted with the latest code is we call <code>is_x86_feature_detected</code> every time <code>draw_line</code> is called. Tbf the benchmark is showing this isn&rsquo;t a huge deal, but its still unnecessary. If we wanted to add more SIMD feature levels we&rsquo;d be calling <code>is_x86_feature_detected</code> perhaps multiple times too.</p><p>Talking of SIMD levels, SSE4.2 is supported by almost everyone, so lets try that.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ cargo bench --bench rasterize rasterize_outline_ttf_biohazard -- --baseline default
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>rasterize_outline_ttf_biohazard
</span></span><span style=display:flex><span>        time:   <span style=color:#f92672>[</span>15.143 µs 15.148 µs 15.154 µs<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>        change: <span style=color:#f92672>[</span>-17.860% -17.746% -17.633%<span style=color:#f92672>]</span> <span style=color:#f92672>(</span>p <span style=color:#f92672>=</span> 0.00 &lt; 0.05<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>SSE4.2 provides a great speedup, not quite as effective as AVX2 but definitely worth having for those without the newer instruction.</p><p>We can do feature detection, including SSE4.2, earlier saving the best function path to use and just calling that pointer in <code>draw_line</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>DrawLineFn</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>fn</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> Rasterizer, Point, Point);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Rasterizer {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>(width: <span style=color:#66d9ef>usize</span>, height: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// runtime detect optimal simd impls
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> draw_line_fn: <span style=color:#a6e22e>DrawLineFn</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> is_x86_feature_detected!(<span style=color:#e6db74>&#34;avx2&#34;</span>) {
</span></span><span style=display:flex><span>            draw_line_avx2
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> is_x86_feature_detected!(<span style=color:#e6db74>&#34;sse4.2&#34;</span>) {
</span></span><span style=display:flex><span>            draw_line_sse4_2
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            Self::draw_line_scalar
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Self {
</span></span><span style=display:flex><span>            width,
</span></span><span style=display:flex><span>            height,
</span></span><span style=display:flex><span>            a: <span style=color:#a6e22e>vec</span><span style=color:#f92672>!</span>[<span style=color:#ae81ff>0.0</span>; width <span style=color:#f92672>*</span> height <span style=color:#f92672>+</span> <span style=color:#ae81ff>4</span>],
</span></span><span style=display:flex><span>            draw_line_fn,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>draw_line</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, p0: <span style=color:#a6e22e>Point</span>, p1: <span style=color:#a6e22e>Point</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsafe</span> { (self.draw_line_fn)(self, p0, p1) }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[inline(always)]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>draw_line_scalar</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, p0: <span style=color:#a6e22e>Point</span>, p1: <span style=color:#a6e22e>Point</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* maths-loops */</span> 
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[target_feature(enable = </span><span style=color:#e6db74>&#34;avx2&#34;</span><span style=color:#75715e>)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>draw_line_avx2</span>(rast: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Rasterizer, p0: <span style=color:#a6e22e>Point</span>, p1: <span style=color:#a6e22e>Point</span>) {
</span></span><span style=display:flex><span>    rast.draw_line_scalar(p0, p1)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[target_feature(enable = </span><span style=color:#e6db74>&#34;sse4.2&#34;</span><span style=color:#75715e>)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>draw_line_sse4_2</span>(rast: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Rasterizer, p0: <span style=color:#a6e22e>Point</span>, p1: <span style=color:#a6e22e>Point</span>) {
</span></span><span style=display:flex><span>    rast.draw_line_scalar(p0, p1)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now when calling <code>Rasterizer::new</code> we&rsquo;ll pick an AVX2 draw-line fn or a SSE4.2 fn or, if neither are supported, the default scaler code. Now we have 3 compiled versions of this function selected during runtime providing almost everyone with more optimal performance and breaking no-one.</p><blockquote><p>It would be cool to use <a href=https://github.com/matklad/once_cell>once_cell</a> for this so the function was picked just once. But in my case I wanted to avoid dependencies for this crate. I&rsquo;d love once_cell to be in std!</p><p><em>Update 2023-01-12: This can also be done without additional dependencies using <code>std::sync::Once</code>. See <a href=https://github.com/alexheretic/ab-glyph/pull/71>ab-glyph#71</a>.</em></p></blockquote><h2 id=no_std--non-x86-compatibility>no_std & non-x86 compatibility
<span><a href=#no_std--non-x86-compatibility><svg viewBox="0 0 28 23" height="100%" width="19"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h2><p>My CPU and my optimisations are targeting x86_64 arch. However, <em>ab_glyph_rasterizer</em> is used on other CPUs and in no_std environments.</p><ul><li><code>#[target_feature(enable = "avx2")]</code> doesn&rsquo;t compile outside x86/x86_64</li><li><code>is_x86_feature_detected!</code> is in std, not available for no_std.</li></ul><p>I&rsquo;ve made my code work for all x86 & x86_64 CPUs but broken compilation elsewhere :(</p><p>We can fix this with more conditional compilation.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Rasterizer {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>(width: <span style=color:#66d9ef>usize</span>, height: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// runtime detect optimal simd impls
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>#[cfg(all(feature = </span><span style=color:#e6db74>&#34;std&#34;</span><span style=color:#75715e>, any(target_arch = </span><span style=color:#e6db74>&#34;x86&#34;</span><span style=color:#75715e>, target_arch = </span><span style=color:#e6db74>&#34;x86_64&#34;</span><span style=color:#75715e>)))]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> draw_line_fn: <span style=color:#a6e22e>DrawLineFn</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> is_x86_feature_detected!(<span style=color:#e6db74>&#34;avx2&#34;</span>) {
</span></span><span style=display:flex><span>            draw_line_avx2
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> is_x86_feature_detected!(<span style=color:#e6db74>&#34;sse4.2&#34;</span>) {
</span></span><span style=display:flex><span>            draw_line_sse4_2
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            Self::draw_line_scalar
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=color:#75715e>#[cfg(any(
</span></span></span><span style=display:flex><span><span style=color:#75715e>            not(feature = </span><span style=color:#e6db74>&#34;std&#34;</span><span style=color:#75715e>),
</span></span></span><span style=display:flex><span><span style=color:#75715e>            not(any(target_arch = </span><span style=color:#e6db74>&#34;x86&#34;</span><span style=color:#75715e>, target_arch = </span><span style=color:#e6db74>&#34;x86_64&#34;</span><span style=color:#75715e>))
</span></span></span><span style=display:flex><span><span style=color:#75715e>        ))]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> draw_line_fn: <span style=color:#a6e22e>DrawLineFn</span> <span style=color:#f92672>=</span> Self::draw_line_scalar;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Self {
</span></span><span style=display:flex><span>            width,
</span></span><span style=display:flex><span>            height,
</span></span><span style=display:flex><span>            a: <span style=color:#a6e22e>vec</span><span style=color:#f92672>!</span>[<span style=color:#ae81ff>0.0</span>; width <span style=color:#f92672>*</span> height <span style=color:#f92672>+</span> <span style=color:#ae81ff>4</span>],
</span></span><span style=display:flex><span>            draw_line_fn,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// draw_line, draw_line_scalar unchanged
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[cfg(all(feature = </span><span style=color:#e6db74>&#34;std&#34;</span><span style=color:#75715e>, any(target_arch = </span><span style=color:#e6db74>&#34;x86&#34;</span><span style=color:#75715e>, target_arch = </span><span style=color:#e6db74>&#34;x86_64&#34;</span><span style=color:#75715e>)))]</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[target_feature(enable = </span><span style=color:#e6db74>&#34;avx2&#34;</span><span style=color:#75715e>)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>draw_line_avx2</span>(rast: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Rasterizer, p0: <span style=color:#a6e22e>Point</span>, p1: <span style=color:#a6e22e>Point</span>) {
</span></span><span style=display:flex><span>    rast.draw_line_scalar(p0, p1)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[cfg(all(feature = </span><span style=color:#e6db74>&#34;std&#34;</span><span style=color:#75715e>, any(target_arch = </span><span style=color:#e6db74>&#34;x86&#34;</span><span style=color:#75715e>, target_arch = </span><span style=color:#e6db74>&#34;x86_64&#34;</span><span style=color:#75715e>)))]</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[target_feature(enable = </span><span style=color:#e6db74>&#34;sse4.2&#34;</span><span style=color:#75715e>)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>draw_line_sse4_2</span>(rast: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Rasterizer, p0: <span style=color:#a6e22e>Point</span>, p1: <span style=color:#a6e22e>Point</span>) {
</span></span><span style=display:flex><span>    rast.draw_line_scalar(p0, p1)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Finally we&rsquo;re up to date with where <a href=https://github.com/alexheretic/ab-glyph/blob/main/rasterizer/src/raster.rs><em>ab_glyph_rasterizer</em> is now</a>. We have AVX2 & SSE4.2 auto-vectorized versions of <code>draw_line</code> while continuing to support no_std & non-x86.</p><p>In future it&rsquo;ll be simple enough to add add paths for AVX512 and for other arch SIMD. These just require testing to prove they are worthwhile. My 5800x sadly does not support AVX512.</p><h2 id=an-easier-way-multiversion>An easier way: multiversion
<span><a href=#an-easier-way-multiversion><svg viewBox="0 0 28 23" height="100%" width="19"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h2><p>Btw this concept of runtime selected pre-compiled optimised functions is called <strong>multiversioning</strong>. And yes, there is a crate to help reduce the noise a bit. <a href=https://github.com/calebzulawski/multiversion>multiversion</a> can help compress our code.</p><p>So lets go back to the start and optimise this function for AVX2 & SSE4.2 similarly to how we just did manually.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Rasterizer {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>draw_line</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, p0: <span style=color:#a6e22e>Point</span>, p1: <span style=color:#a6e22e>Point</span>) { 
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* maths-loops */</span> 
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>cargo add multiversion</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Rasterizer {
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[multiversion::multiversion]</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[clone(target = </span><span style=color:#e6db74>&#34;[x86|x86_64]+avx2&#34;</span><span style=color:#75715e>)]</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[clone(target = </span><span style=color:#e6db74>&#34;[x86|x86_64]+sse4.2&#34;</span><span style=color:#75715e>)]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>draw_line</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, p0: <span style=color:#a6e22e>Point</span>, p1: <span style=color:#a6e22e>Point</span>) { 
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* maths-loops */</span> 
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Instead of the manual impl we use 3 lines of proc-macro DSL.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ cargo bench --bench rasterize rasterize_outline_ttf_biohazard -- --baseline default
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>rasterize_outline_ttf_biohazard
</span></span><span style=display:flex><span>        time:   <span style=color:#f92672>[</span>14.479 µs 14.482 µs 14.485 µs<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>        change: <span style=color:#f92672>[</span>-21.446% -21.335% -21.230%<span style=color:#f92672>]</span> <span style=color:#f92672>(</span>p <span style=color:#f92672>=</span> 0.00 &lt; 0.05<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>And it works (always worth checking!).</p><p>The expanded code seems to be equivalent to when we were doing simple <code>if is_x86_feature_detected!</code> inside <code>draw_line</code> fn. We don&rsquo;t have the same control over the feature detection to optimise it. Another issue here is that example is no longer no_std compatible, but it should be possible to do so by sprinkling the required conditional compilation flags.</p><p><a href=https://github.com/calebzulawski/multiversion>multiversion</a> seems a pretty nice way to introduce runtime selected auto-vectorization to your code with minimal noise.</p><blockquote><p>Note: For <em>ab_glyph_rasterizer</em> I kept a manual implementation, primarily to keep <em>ab_glyph_rasterizer</em> at zero dependencies.</p></blockquote><h2 id=hand-written-simd>Hand-written SIMD
<span><a href=#hand-written-simd><svg viewBox="0 0 28 23" height="100%" width="19"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h2><p>I find the auto-vectorized code to be fairly easy to maintain as there isn&rsquo;t any new &ldquo;logic&rdquo; bits to handle, just conditional compilation to wrangle. Writing the SIMD intrinsics by hand is much harder and more difficult to maintain.</p><p>On the other hand, reading <a href=https://www.nickwilcox.com/blog/autovec2/>Nick Wilcox&rsquo;s Auto-Vectorization for Newer Instruction Sets in Rust</a> we can see it can also yield significantly better results. Try it if you dare!</p><h2 id=conclusion>Conclusion
<span><a href=#conclusion><svg viewBox="0 0 28 23" height="100%" width="19"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h2><p>To summarize: If you want to SIMD optimise some code:</p><ul><li>Write a benchmark.</li><li>Try vs <code>RUSTFLAGS='-C target-cpu=native'</code>.</li><li>If that&rsquo;s promising, try targeting functions with <code>#[target_feature</code></li><li>If that works, try properly multiversioning either manually or with the crate.</li></ul><p>Good luck optimising, lets make the most of our CPUs!</p></div><div class=post-info><div class="post-date dt-published"><a class=u-url href=/posts/auto-avx2/><time datetime=2022-11-12>2022-11-12</time></a></div><a class="post-hidden-url u-url" href=https://alexheretic.github.io/posts/auto-avx2/>https://alexheretic.github.io/posts/auto-avx2/</a>
<a href=https://alexheretic.github.io/ class="p-name p-author post-hidden-author h-card" rel=me>Alex Butler</a><div class=post-taxonomies></div></div></article><div class="pagination post-pagination"><div class="left pagination-item disabled"></div><div class="right pagination-item"><a href=/posts/ab-av1-2/>ab-av1: Letting other encoders in to the party</a></div></div></main><footer class=common-footer><div class=common-footer-bottom><div class=copyright><p>© Alex Butler, 2024<br></p></div><div class=theme-switcher><span class=inline-svg><svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 290 290"><path fill="currentcolor" d="M142.959.0C64.131.0.0 64.132.0 142.96s64.131 142.959 142.959 142.959 142.96-64.131 142.96-142.959C285.919 64.132 221.787.0 142.959.0zm0 260.919V142.96 25c65.043.0 117.96 52.917 117.96 117.96.0 65.043-52.917 117.959-117.96 117.959z"/></svg></span></div><script>const STORAGE_KEY="user-color-scheme",defaultTheme="dark";let currentTheme,switchButton,autoDefinedScheme=window.matchMedia("(prefers-color-scheme: dark)");const autoChangeScheme=e=>{currentTheme=e.matches?"dark":"light",document.documentElement.setAttribute("data-theme",currentTheme)};document.addEventListener("DOMContentLoaded",function(){switchButton=document.querySelector(".theme-switcher"),currentTheme=detectCurrentScheme(),currentTheme=="dark"&&document.documentElement.setAttribute("data-theme","dark"),currentTheme=="auto"&&(autoChangeScheme(autoDefinedScheme),autoDefinedScheme.addListener(autoChangeScheme)),switchButton&&switchButton.addEventListener("click",switchTheme,!1),showContent()});function detectCurrentScheme(){return localStorage!==null&&localStorage.getItem(STORAGE_KEY)?localStorage.getItem(STORAGE_KEY):defaultTheme?defaultTheme:window.matchMedia?window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light":"light"}function switchTheme(){currentTheme=="dark"?(localStorage!==null&&localStorage.setItem(STORAGE_KEY,"light"),document.documentElement.setAttribute("data-theme","light"),currentTheme="light"):(localStorage!==null&&localStorage.setItem(STORAGE_KEY,"dark"),document.documentElement.setAttribute("data-theme","dark"),currentTheme="dark")}function showContent(){document.body.style.visibility="visible",document.body.style.opacity=1}</script></div><p class="h-card vcard"><a href=https://alexheretic.github.io/ class="p-name u-url url fn" rel=me>Alex Butler</a>
<img class=u-photo src=/images/me.webp></p></footer></div></body></html>