<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>alex posts</title><link>https://alexheretic.github.io/</link><description>alex posts</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><lastBuildDate>Sat, 12 Nov 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://alexheretic.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Getting rustc to use AVX2 SIMD</title><link>https://alexheretic.github.io/posts/auto-avx2/</link><pubDate>Sat, 12 Nov 2022 00:00:00 +0000</pubDate><guid>https://alexheretic.github.io/posts/auto-avx2/</guid><description>&lt;p>SIMD roughly means CPU instructions that do multiple things at once. Making use of them can make algorithms faster. The rust compiler actually uses them automatically, but it &lt;em>doesn&amp;rsquo;t&lt;/em> for newer SIMD instructions like SSE4.2 &amp;amp; AVX2.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>SIMD Feature&lt;/th>
&lt;th>Coverage&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>SSE2&lt;/td>
&lt;td>100%&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>SSE4.2&lt;/td>
&lt;td>99.1%&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>AVX2&lt;/td>
&lt;td>89.2%&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>AVX512F&lt;/td>
&lt;td>8.73%&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;em>Steam survey October 2022&lt;/em>&lt;/p>
&lt;p>Rustc can&amp;rsquo;t use them by default because not every CPU will work with them. But these days most CPUs &lt;em>do&lt;/em> support these newer instructions and so certain tasks can be a &lt;strong>lot&lt;/strong> faster for a lot of people.&lt;/p>
&lt;h2 id="what-code-can-be-optimised" >What code can be optimised?
&lt;span>
&lt;a href="#what-code-can-be-optimised">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Without a good understanding of SIMD it can be hard to know what kind of tasks should benefit, but at a high level what I look for is &lt;strong>loops with maths in the middle&lt;/strong>. If we&amp;rsquo;re looping over a load of data and doing maths there&amp;rsquo;s a chance this could be vectorized, which means the data gets packed together and requires lower total number of SIMD instructions to reach the same result.&lt;/p>
&lt;p>For example my crate &lt;a href="https://github.com/alexheretic/ab-glyph/tree/main/rasterizer">ab_glyph_rasterizer&lt;/a> rasterization logic I know is an expensive operation. This involves drawing a font glyph&amp;rsquo;s outline onto a 2d coverage grid. There are some loops with maths in the middle there so &lt;em>can rustc make it faster on my CPU?&lt;/em>&lt;/p>
&lt;h2 id="benchmarking" >Benchmarking
&lt;span>
&lt;a href="#benchmarking">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>My first step to optimising code is to write a benchmark. Optimising is &lt;em>hard&lt;/em>. A benchmark can tell you if an optimisation has actually worked. This is important as optimisations often bloat the code and make it less readable in the name of performance, so you really should be proving that the performance has improved!&lt;/p>
&lt;p>I already had some benches for &lt;em>ab_glyph_rasterizer&lt;/em> so lets fire one up using default rustc settings.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>$ cargo bench --bench rasterize rasterize_outline_ttf_biohazard -- --save-baseline default
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rasterize_outline_ttf_biohazard
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> time: &lt;span style="color:#f92672">[&lt;/span>18.383 µs 18.385 µs 18.388 µs&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div style="font-size:1000%;line-height:100%;">☣&lt;/div>
&lt;p>So rasterizing a 294x269px biohazard glyph on my 5800x takes &lt;strong>~18.4µs&lt;/strong>.&lt;/p>
&lt;blockquote>
&lt;p>Aside: Writing benchmarks is also hard. I ran mine 4 times and got 19.3µs, 18.8µs, 18.5µs, 18.4µs so I&amp;rsquo;ll need to take the noise into account before I start celebrating a win that was just noise.&lt;/p>
&lt;/blockquote>
&lt;p>The cool thing about having a benchmark is we can start investigating if SIMD is going to help us &lt;strong>without writing any clever code&lt;/strong>.&lt;/p>
&lt;h2 id="benching-with-target-cpunative" >Benching with target-cpu=native
&lt;span>
&lt;a href="#benching-with-target-cpunative">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>I can tell rustc to use all the SIMD instructions my CPU supports and benchmark again.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>$ RUSTFLAGS&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;-C target-cpu=native&amp;#39;&lt;/span> cargo bench --bench rasterize rasterize_outline_ttf_biohazard -- --baseline default
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rasterize_outline_ttf_biohazard
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> time: &lt;span style="color:#f92672">[&lt;/span>14.224 µs 14.242 µs 14.264 µs&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> change: &lt;span style="color:#f92672">[&lt;/span>-22.094% -21.920% -21.752%&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>p &lt;span style="color:#f92672">=&lt;/span> 0.00 &amp;lt; 0.05&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We can draw the same glyph in &lt;strong>~14.2µs&lt;/strong> now. A nice speedup for no extra code! This is an indication that the code we&amp;rsquo;re benchmarking could benefit from auto-vectorization.&lt;/p>
&lt;p>We can also try to generalize a bit. Lets try just enabling AVX2 since I know that&amp;rsquo;s one of the newest SIMD features my CPU supports.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>$ RUSTFLAGS&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;-C target-feature=+avx2&amp;#39;&lt;/span> cargo bench --bench rasterize rasterize_outline_ttf_biohazard -- --baseline default
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rasterize_outline_ttf_biohazard
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> time: &lt;span style="color:#f92672">[&lt;/span>14.412 µs 14.419 µs 14.427 µs&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> change: &lt;span style="color:#f92672">[&lt;/span>-21.843% -21.726% -21.613%&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>p &lt;span style="color:#f92672">=&lt;/span> 0.00 &amp;lt; 0.05&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>So we get pretty much the same benefit by simply enabling AVX2.&lt;/p>
&lt;p>But we&amp;rsquo;re not done. If I compile, for example, my game with &lt;code>RUSTFLAGS='-C target-feature=+avx2'&lt;/code> it will be faster. But it will also stop working for ~11% of my game&amp;rsquo;s players, which is obviously not ok. We want to enable AVX2 for CPUs that support it and use the old code for everyone else.&lt;/p>
&lt;h2 id="targeting-the-functions-to-auto-vectorize" >Targeting the functions to auto-vectorize
&lt;span>
&lt;a href="#targeting-the-functions-to-auto-vectorize">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>As a first step to runtime enabling AVX2 I started looking for particular functions that I&amp;rsquo;d like to auto-vectorize. I found &lt;a href="https://github.com/alexheretic/ab-glyph/blob/65064cf8d21affe27cce0e23535bc9a8cb02e8a4/rasterizer/src/raster.rs#L97">&lt;code>Rasterizer::draw_line&lt;/code>&lt;/a> which is the core fn for this task and it has loop with tons of maths inside.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span> Rasterizer {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">draw_line&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> self, p0: &lt;span style="color:#a6e22e">Point&lt;/span>, p1: &lt;span style="color:#a6e22e">Point&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* maths-loops */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">..&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We can instruct rustc to compile this using AVX2.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[target_feature(enable = &lt;/span>&lt;span style="color:#e6db74">&amp;#34;avx2&amp;#34;&lt;/span>&lt;span style="color:#75715e">)]&lt;/span> &lt;span style="color:#75715e">// doesn&amp;#39;t compile!
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">draw_line&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> self, p0: &lt;span style="color:#a6e22e">Point&lt;/span>, p1: &lt;span style="color:#a6e22e">Point&lt;/span>) {
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This doesn&amp;rsquo;t work because:&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>#[target_feature(..)]&lt;/code> can only be applied to &lt;code>unsafe&lt;/code> functions&lt;/p>
&lt;/blockquote>
&lt;p>Actually that makes sense, after all it won&amp;rsquo;t work on all CPUs. Lets just do it anyway.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">draw_line&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> self, p0: &lt;span style="color:#a6e22e">Point&lt;/span>, p1: &lt;span style="color:#a6e22e">Point&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsafe&lt;/span> { self.draw_line_avx2(p0, p1) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[target_feature(enable = &lt;/span>&lt;span style="color:#e6db74">&amp;#34;avx2&amp;#34;&lt;/span>&lt;span style="color:#75715e">)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">unsafe&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">draw_line_avx2&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> self, p0: &lt;span style="color:#a6e22e">Point&lt;/span>, p1: &lt;span style="color:#a6e22e">Point&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* maths-loops */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now we&amp;rsquo;ve enabled AVX2 for this function we can bench again without any RUSTFLAGS.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>$ cargo bench --bench rasterize rasterize_outline_ttf_biohazard -- --baseline default
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rasterize_outline_ttf_biohazard
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> time: &lt;span style="color:#f92672">[&lt;/span>14.273 µs 14.276 µs 14.280 µs&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> change: &lt;span style="color:#f92672">[&lt;/span>-22.566% -22.456% -22.352%&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>p &lt;span style="color:#f92672">=&lt;/span> 0.00 &amp;lt; 0.05&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>So indeed this function is the place to be SIMD-ing! We&amp;rsquo;re still not there yet though since the change &lt;em>still&lt;/em> breaks any non-AVX2 CPU.&lt;/p>
&lt;h2 id="runtime-detection" >Runtime detection
&lt;span>
&lt;a href="#runtime-detection">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>We could wrap this optimisation in a compile time feature. But it isn&amp;rsquo;t usually very useful to do so. All usage of this dependency would have to wire up the feature and ultimately something like my game would need a single binary to work for many different CPU feature levels.&lt;/p>
&lt;p>What we want is runtime detection. We can do that with &lt;strong>&lt;a href="https://doc.rust-lang.org/std/macro.is_x86_feature_detected.html">std::is_x86_feature_detected&lt;/a>&lt;/strong>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">draw_line&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> self, p0: &lt;span style="color:#a6e22e">Point&lt;/span>, p1: &lt;span style="color:#a6e22e">Point&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> is_x86_feature_detected!(&lt;span style="color:#e6db74">&amp;#34;avx2&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsafe&lt;/span> { self.draw_line_avx2(p0, p1) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self.draw_line_scalar(p0, p1)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[target_feature(enable = &lt;/span>&lt;span style="color:#e6db74">&amp;#34;avx2&amp;#34;&lt;/span>&lt;span style="color:#75715e">)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">unsafe&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">draw_line_avx2&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> self, p0: &lt;span style="color:#a6e22e">Point&lt;/span>, p1: &lt;span style="color:#a6e22e">Point&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* maths-loops */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">draw_line_scalar&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> self, p0: &lt;span style="color:#a6e22e">Point&lt;/span>, p1: &lt;span style="color:#a6e22e">Point&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* the same maths-loops */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now we&amp;rsquo;re actually getting somewhere. Our code is actually safe so should work everywhere.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>$ cargo bench --bench rasterize rasterize_outline_ttf_biohazard -- --baseline default
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rasterize_outline_ttf_biohazard
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> time: &lt;span style="color:#f92672">[&lt;/span>14.415 µs 14.419 µs 14.424 µs&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> change: &lt;span style="color:#f92672">[&lt;/span>-21.784% -21.665% -21.553%&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>p &lt;span style="color:#f92672">=&lt;/span> 0.00 &amp;lt; 0.05&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Benching the code shows we&amp;rsquo;re still getting the benefit.&lt;/p>
&lt;h2 id="inlining" >Inlining
&lt;span>
&lt;a href="#inlining">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>One issue with this version however is the bulk of my code, the loops, has been duplicated. So there&amp;rsquo;s a bunch more code. We can fix this fairly easily with inlining.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">draw_line&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> self, p0: &lt;span style="color:#a6e22e">Point&lt;/span>, p1: &lt;span style="color:#a6e22e">Point&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> is_x86_feature_detected!(&lt;span style="color:#e6db74">&amp;#34;avx2&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsafe&lt;/span> { self.draw_line_avx2(p0, p1) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self.draw_line_scalar(p0, p1)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[target_feature(enable = &lt;/span>&lt;span style="color:#e6db74">&amp;#34;avx2&amp;#34;&lt;/span>&lt;span style="color:#75715e">)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">unsafe&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">draw_line_avx2&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> self, p0: &lt;span style="color:#a6e22e">Point&lt;/span>, p1: &lt;span style="color:#a6e22e">Point&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self.draw_line_scalar(p0, p1)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[inline(always)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">draw_line_scalar&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> self, p0: &lt;span style="color:#a6e22e">Point&lt;/span>, p1: &lt;span style="color:#a6e22e">Point&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* maths-loops */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This did look kinda funny to me the first time. The implementation of &lt;code>draw_line_avx2&lt;/code> is just calling &lt;code>draw_line_scalar&lt;/code>. It looks a bit pointless from a logical point of view, but this is for the compiler rather than for us. Note &lt;code>#[inline(always)]&lt;/code> is important because we need rustc to duplicate the compilation to get 2 compiled versions of draw-line, one with AVX2 instructions.&lt;/p>
&lt;p>Now we have a legit optimisation to the code. Not too much extra code, just some feature detection wiring and inlining.&lt;/p>
&lt;h2 id="optimising-feature-detection--sse42" >Optimising feature detection &amp;amp; SSE4.2
&lt;span>
&lt;a href="#optimising-feature-detection--sse42">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>An issue you may have spotted with the latest code is we call &lt;code>is_x86_feature_detected&lt;/code> every time &lt;code>draw_line&lt;/code> is called. Tbf the benchmark is showing this isn&amp;rsquo;t a huge deal, but its still unnecessary. If we wanted to add more SIMD feature levels we&amp;rsquo;d be calling &lt;code>is_x86_feature_detected&lt;/code> perhaps multiple times too.&lt;/p>
&lt;p>Talking of SIMD levels, SSE4.2 is supported by almost everyone, so lets try that.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>$ cargo bench --bench rasterize rasterize_outline_ttf_biohazard -- --baseline default
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rasterize_outline_ttf_biohazard
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> time: &lt;span style="color:#f92672">[&lt;/span>15.143 µs 15.148 µs 15.154 µs&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> change: &lt;span style="color:#f92672">[&lt;/span>-17.860% -17.746% -17.633%&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>p &lt;span style="color:#f92672">=&lt;/span> 0.00 &amp;lt; 0.05&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>SSE4.2 provides a great speedup, not quite as effective as AVX2 but definitely worth having for those without the newer instruction.&lt;/p>
&lt;p>We can do feature detection, including SSE4.2, earlier saving the best function path to use and just calling that pointer in &lt;code>draw_line&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">DrawLineFn&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">unsafe&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> Rasterizer, Point, Point);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span> Rasterizer {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">new&lt;/span>(width: &lt;span style="color:#66d9ef">usize&lt;/span>, height: &lt;span style="color:#66d9ef">usize&lt;/span>) -&amp;gt; &lt;span style="color:#a6e22e">Self&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// runtime detect optimal simd impls
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> draw_line_fn: &lt;span style="color:#a6e22e">DrawLineFn&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> is_x86_feature_detected!(&lt;span style="color:#e6db74">&amp;#34;avx2&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> draw_line_avx2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> is_x86_feature_detected!(&lt;span style="color:#e6db74">&amp;#34;sse4.2&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> draw_line_sse4_2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Self::draw_line_scalar
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Self {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> width,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> height,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a: &lt;span style="color:#a6e22e">vec&lt;/span>&lt;span style="color:#f92672">!&lt;/span>[&lt;span style="color:#ae81ff">0.0&lt;/span>; width &lt;span style="color:#f92672">*&lt;/span> height &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> draw_line_fn,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">draw_line&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> self, p0: &lt;span style="color:#a6e22e">Point&lt;/span>, p1: &lt;span style="color:#a6e22e">Point&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsafe&lt;/span> { (self.draw_line_fn)(self, p0, p1) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#[inline(always)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">draw_line_scalar&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> self, p0: &lt;span style="color:#a6e22e">Point&lt;/span>, p1: &lt;span style="color:#a6e22e">Point&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* maths-loops */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[target_feature(enable = &lt;/span>&lt;span style="color:#e6db74">&amp;#34;avx2&amp;#34;&lt;/span>&lt;span style="color:#75715e">)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">unsafe&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">draw_line_avx2&lt;/span>(rast: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">mut&lt;/span> Rasterizer, p0: &lt;span style="color:#a6e22e">Point&lt;/span>, p1: &lt;span style="color:#a6e22e">Point&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rast.draw_line_scalar(p0, p1)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[target_feature(enable = &lt;/span>&lt;span style="color:#e6db74">&amp;#34;sse4.2&amp;#34;&lt;/span>&lt;span style="color:#75715e">)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">unsafe&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">draw_line_sse4_2&lt;/span>(rast: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">mut&lt;/span> Rasterizer, p0: &lt;span style="color:#a6e22e">Point&lt;/span>, p1: &lt;span style="color:#a6e22e">Point&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rast.draw_line_scalar(p0, p1)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now when calling &lt;code>Rasterizer::new&lt;/code> we&amp;rsquo;ll pick an AVX2 draw-line fn or a SSE4.2 fn or, if neither are supported, the default scaler code. Now we have 3 compiled versions of this function selected during runtime providing almost everyone with more optimal performance and breaking no-one.&lt;/p>
&lt;blockquote>
&lt;p>It would be cool to use &lt;a href="https://github.com/matklad/once_cell">once_cell&lt;/a> for this so the function was picked just once. But in my case I wanted to avoid dependencies for this crate. I&amp;rsquo;d love once_cell to be in std!&lt;/p>
&lt;p>&lt;em>Update 2023-01-12: This can also be done without additional dependencies using &lt;code>std::sync::Once&lt;/code>. See &lt;a href="https://github.com/alexheretic/ab-glyph/pull/71">ab-glyph#71&lt;/a>.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;h2 id="no_std--non-x86-compatibility" >no_std &amp;amp; non-x86 compatibility
&lt;span>
&lt;a href="#no_std--non-x86-compatibility">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>My CPU and my optimisations are targeting x86_64 arch. However, &lt;em>ab_glyph_rasterizer&lt;/em> is used on other CPUs and in no_std environments.&lt;/p>
&lt;ul>
&lt;li>&lt;code>#[target_feature(enable = &amp;quot;avx2&amp;quot;)]&lt;/code> doesn&amp;rsquo;t compile outside x86/x86_64&lt;/li>
&lt;li>&lt;code>is_x86_feature_detected!&lt;/code> is in std, not available for no_std.&lt;/li>
&lt;/ul>
&lt;p>I&amp;rsquo;ve made my code work for all x86 &amp;amp; x86_64 CPUs but broken compilation elsewhere :(&lt;/p>
&lt;p>We can fix this with more conditional compilation.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span> Rasterizer {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">new&lt;/span>(width: &lt;span style="color:#66d9ef">usize&lt;/span>, height: &lt;span style="color:#66d9ef">usize&lt;/span>) -&amp;gt; &lt;span style="color:#a6e22e">Self&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// runtime detect optimal simd impls
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">#[cfg(all(feature = &lt;/span>&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>&lt;span style="color:#75715e">, any(target_arch = &lt;/span>&lt;span style="color:#e6db74">&amp;#34;x86&amp;#34;&lt;/span>&lt;span style="color:#75715e">, target_arch = &lt;/span>&lt;span style="color:#e6db74">&amp;#34;x86_64&amp;#34;&lt;/span>&lt;span style="color:#75715e">)))]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> draw_line_fn: &lt;span style="color:#a6e22e">DrawLineFn&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> is_x86_feature_detected!(&lt;span style="color:#e6db74">&amp;#34;avx2&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> draw_line_avx2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> is_x86_feature_detected!(&lt;span style="color:#e6db74">&amp;#34;sse4.2&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> draw_line_sse4_2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Self::draw_line_scalar
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#[cfg(any(
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> not(feature = &lt;/span>&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>&lt;span style="color:#75715e">),
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> not(any(target_arch = &lt;/span>&lt;span style="color:#e6db74">&amp;#34;x86&amp;#34;&lt;/span>&lt;span style="color:#75715e">, target_arch = &lt;/span>&lt;span style="color:#e6db74">&amp;#34;x86_64&amp;#34;&lt;/span>&lt;span style="color:#75715e">))
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> ))]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> draw_line_fn: &lt;span style="color:#a6e22e">DrawLineFn&lt;/span> &lt;span style="color:#f92672">=&lt;/span> Self::draw_line_scalar;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Self {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> width,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> height,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a: &lt;span style="color:#a6e22e">vec&lt;/span>&lt;span style="color:#f92672">!&lt;/span>[&lt;span style="color:#ae81ff">0.0&lt;/span>; width &lt;span style="color:#f92672">*&lt;/span> height &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> draw_line_fn,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// draw_line, draw_line_scalar unchanged
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[cfg(all(feature = &lt;/span>&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>&lt;span style="color:#75715e">, any(target_arch = &lt;/span>&lt;span style="color:#e6db74">&amp;#34;x86&amp;#34;&lt;/span>&lt;span style="color:#75715e">, target_arch = &lt;/span>&lt;span style="color:#e6db74">&amp;#34;x86_64&amp;#34;&lt;/span>&lt;span style="color:#75715e">)))]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[target_feature(enable = &lt;/span>&lt;span style="color:#e6db74">&amp;#34;avx2&amp;#34;&lt;/span>&lt;span style="color:#75715e">)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">unsafe&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">draw_line_avx2&lt;/span>(rast: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">mut&lt;/span> Rasterizer, p0: &lt;span style="color:#a6e22e">Point&lt;/span>, p1: &lt;span style="color:#a6e22e">Point&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rast.draw_line_scalar(p0, p1)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[cfg(all(feature = &lt;/span>&lt;span style="color:#e6db74">&amp;#34;std&amp;#34;&lt;/span>&lt;span style="color:#75715e">, any(target_arch = &lt;/span>&lt;span style="color:#e6db74">&amp;#34;x86&amp;#34;&lt;/span>&lt;span style="color:#75715e">, target_arch = &lt;/span>&lt;span style="color:#e6db74">&amp;#34;x86_64&amp;#34;&lt;/span>&lt;span style="color:#75715e">)))]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[target_feature(enable = &lt;/span>&lt;span style="color:#e6db74">&amp;#34;sse4.2&amp;#34;&lt;/span>&lt;span style="color:#75715e">)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">unsafe&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">draw_line_sse4_2&lt;/span>(rast: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">mut&lt;/span> Rasterizer, p0: &lt;span style="color:#a6e22e">Point&lt;/span>, p1: &lt;span style="color:#a6e22e">Point&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rast.draw_line_scalar(p0, p1)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Finally we&amp;rsquo;re up to date with where &lt;a href="https://github.com/alexheretic/ab-glyph/blob/main/rasterizer/src/raster.rs">&lt;em>ab_glyph_rasterizer&lt;/em> is now&lt;/a>. We have AVX2 &amp;amp; SSE4.2 auto-vectorized versions of &lt;code>draw_line&lt;/code> while continuing to support no_std &amp;amp; non-x86.&lt;/p>
&lt;p>In future it&amp;rsquo;ll be simple enough to add add paths for AVX512 and for other arch SIMD. These just require testing to prove they are worthwhile. My 5800x sadly does not support AVX512.&lt;/p>
&lt;h2 id="an-easier-way-multiversion" >An easier way: multiversion
&lt;span>
&lt;a href="#an-easier-way-multiversion">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Btw this concept of runtime selected pre-compiled optimised functions is called &lt;strong>multiversioning&lt;/strong>. And yes, there is a crate to help reduce the noise a bit. &lt;a href="https://github.com/calebzulawski/multiversion">multiversion&lt;/a> can help compress our code.&lt;/p>
&lt;p>So lets go back to the start and optimise this function for AVX2 &amp;amp; SSE4.2 similarly to how we just did manually.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span> Rasterizer {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">draw_line&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> self, p0: &lt;span style="color:#a6e22e">Point&lt;/span>, p1: &lt;span style="color:#a6e22e">Point&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* maths-loops */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>cargo add multiversion&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span> Rasterizer {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#[multiversion::multiversion]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#[clone(target = &lt;/span>&lt;span style="color:#e6db74">&amp;#34;[x86|x86_64]+avx2&amp;#34;&lt;/span>&lt;span style="color:#75715e">)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#[clone(target = &lt;/span>&lt;span style="color:#e6db74">&amp;#34;[x86|x86_64]+sse4.2&amp;#34;&lt;/span>&lt;span style="color:#75715e">)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">draw_line&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> self, p0: &lt;span style="color:#a6e22e">Point&lt;/span>, p1: &lt;span style="color:#a6e22e">Point&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* maths-loops */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Instead of the manual impl we use 3 lines of proc-macro DSL.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>$ cargo bench --bench rasterize rasterize_outline_ttf_biohazard -- --baseline default
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rasterize_outline_ttf_biohazard
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> time: &lt;span style="color:#f92672">[&lt;/span>14.479 µs 14.482 µs 14.485 µs&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> change: &lt;span style="color:#f92672">[&lt;/span>-21.446% -21.335% -21.230%&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>p &lt;span style="color:#f92672">=&lt;/span> 0.00 &amp;lt; 0.05&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>And it works (always worth checking!).&lt;/p>
&lt;p>The expanded code seems to be equivalent to when we were doing simple &lt;code>if is_x86_feature_detected!&lt;/code> inside &lt;code>draw_line&lt;/code> fn. We don&amp;rsquo;t have the same control over the feature detection to optimise it. Another issue here is that example is no longer no_std compatible, but it should be possible to do so by sprinkling the required conditional compilation flags.&lt;/p>
&lt;p>&lt;a href="https://github.com/calebzulawski/multiversion">multiversion&lt;/a> seems a pretty nice way to introduce runtime selected auto-vectorization to your code with minimal noise.&lt;/p>
&lt;blockquote>
&lt;p>Note: For &lt;em>ab_glyph_rasterizer&lt;/em> I kept a manual implementation, primarily to keep &lt;em>ab_glyph_rasterizer&lt;/em> at zero dependencies.&lt;/p>
&lt;/blockquote>
&lt;h2 id="hand-written-simd" >Hand-written SIMD
&lt;span>
&lt;a href="#hand-written-simd">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>I find the auto-vectorized code to be fairly easy to maintain as there isn&amp;rsquo;t any new &amp;ldquo;logic&amp;rdquo; bits to handle, just conditional compilation to wrangle. Writing the SIMD intrinsics by hand is much harder and more difficult to maintain.&lt;/p>
&lt;p>On the other hand, reading &lt;a href="https://www.nickwilcox.com/blog/autovec2/">Nick Wilcox&amp;rsquo;s Auto-Vectorization for Newer Instruction Sets in Rust&lt;/a> we can see it can also yield significantly better results. Try it if you dare!&lt;/p>
&lt;h2 id="conclusion" >Conclusion
&lt;span>
&lt;a href="#conclusion">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>To summarize: If you want to SIMD optimise some code:&lt;/p>
&lt;ul>
&lt;li>Write a benchmark.&lt;/li>
&lt;li>Try vs &lt;code>RUSTFLAGS='-C target-cpu=native'&lt;/code>.&lt;/li>
&lt;li>If that&amp;rsquo;s promising, try targeting functions with &lt;code>#[target_feature&lt;/code>&lt;/li>
&lt;li>If that works, try properly multiversioning either manually or with the crate.&lt;/li>
&lt;/ul>
&lt;p>Good luck optimising, lets make the most of our CPUs!&lt;/p></description></item><item><title>ab-av1: Letting other encoders in to the party</title><link>https://alexheretic.github.io/posts/ab-av1-2/</link><pubDate>Fri, 22 Jul 2022 00:00:00 +0000</pubDate><guid>https://alexheretic.github.io/posts/ab-av1-2/</guid><description>&lt;p>Since &lt;a href="https://alexheretic.github.io/posts/ab-av1">posting about ab-av1&lt;/a> I&amp;rsquo;ve been improving the tool. v0.2.0 brought support for automatic key interval setting, arbitrary svt-av1 arguments, configurable vfilters &amp;amp; pixel format. Later in v0.3.0 I improved VMAF with automatic model selection &amp;amp; automatic upscaling to the selected model.&lt;/p>
&lt;p>When I found myself wanting to encode in an older format (e.g. x264/x265) to target somewhere without as good av1 support, I really missed not being able to use ab-av1&amp;rsquo;s &lt;em>auto-encode&lt;/em> / &lt;em>crf-search&lt;/em>. So &lt;a href="https://github.com/alexheretic/ab-av1/blob/main/CHANGELOG.md#v040">&lt;strong>v0.4.0&lt;/strong>&lt;/a> is now available has new option &lt;code>--encoder&lt;/code>/&lt;code>-e&lt;/code> which can override the default svt-av1 encoder to use any ffmpeg encoder instead.&lt;/p>
&lt;p>This opens the doors to a world of fast crf searching &amp;amp; auto encoding with any video encoder you like.&lt;/p>
&lt;h2 id="examples" >Examples
&lt;span>
&lt;a href="#examples">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;h3 id="x264" >x264
&lt;span>
&lt;a href="#x264">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>Lets take it for a spin with a high bitrate h264 1.1GB video re-encoding to a smaller size with at least 95 VMAF using good old &lt;strong>libx264&lt;/strong>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>ab-av1 crf-search -e libx264 -i vid.mp4
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="libx264.png" alt="" title="crf-search with libx264">&lt;/p>
&lt;p>So instead of using &lt;em>SvtAv1EncApp&lt;/em> to encode we&amp;rsquo;ll call &lt;em>ffmpeg&lt;/em> instead with vcodec libx264. We can still do some of the nice things we do with the default encoder like set keyint (aka &lt;code>-g&lt;/code> in ffmpeg) to 10s correctly depending on the input framerate.&lt;/p>
&lt;h3 id="x265" >x265
&lt;span>
&lt;a href="#x265">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>How about &lt;strong>libx265&lt;/strong> which should be more efficient.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>ab-av1 crf-search -e libx265 -i vid.mp4
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="libx265.png" alt="" title="crf-search with libx265">&lt;/p>
&lt;p>Yeah a pretty nice reduction in size, though encoding isn&amp;rsquo;t quite as speedy as it&amp;rsquo;s dad.&lt;/p>
&lt;h3 id="va-api" >VA-API
&lt;span>
&lt;a href="#va-api">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>Since we can use anything that works with ffmpeg we can even try GPU accelerated encoding. My GPU supports h265 encoding. Though crf encoding isn&amp;rsquo;t supported we can set the somewhat equivalent &lt;code>-qp&lt;/code> quality which ab-av1 will automatically use for vaapi encoders.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>ab-av1 crf-search -e hevc_vaapi -i vid.mp4 &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --enc-input hwaccel&lt;span style="color:#f92672">=&lt;/span>vaapi &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --enc-input hwaccel_output_format&lt;span style="color:#f92672">=&lt;/span>vaapi
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="hevc_vaapi.png" alt="" title="crf-search with hevc_vaapi">&lt;/p>
&lt;p>It is very fast and doesn&amp;rsquo;t use CPU. But not as flexible to use as the CPU encoders plus no way to configure the quality/speed trade off. It will be interesting to see GPU AV1 encoders!&lt;/p>
&lt;h3 id="libaom-av1" >libaom-av1
&lt;span>
&lt;a href="#libaom-av1">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>&lt;em>Still running&amp;hellip;&lt;/em>&lt;/p>
&lt;h3 id="default-svt-av1" >Default: svt-av1
&lt;span>
&lt;a href="#default-svt-av1">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>Finally we have the default encoder svt-av1. It now has a default preset of &lt;strong>8&lt;/strong>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>ab-av1 crf-search -i vid.mp4
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="svt-av1.png" alt="" title="crf-search with svt-av1">&lt;/p>
&lt;p>AV1 is great and using svt-av1 it&amp;rsquo;s fast too, encoding faster than x265 with better compression.&lt;/p>
&lt;h2 id="final-remarks" >Final remarks
&lt;span>
&lt;a href="#final-remarks">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>I was worried the code would get a bit muddled with the addition of configurable encoders, and indeed it does make things a little more complicated. In particular some of the argument &amp;amp; commands may not have the best names now, since an encoder may not even use &amp;ldquo;crf&amp;rdquo; or &amp;ldquo;preset&amp;rdquo;. There is room for improvement perhaps, but with av1 support still not 100% everywhere I think this feature is more than worthwhile.&lt;/p>
&lt;p>There are also vcodec specific tweaks we can make. I&amp;rsquo;ve already added some for vaapi codecs, libvpx-vp9 &amp;amp; libaom-av1 but I&amp;rsquo;m sure more can be added. Head over to the &lt;a href="https://github.com/alexheretic/ab-av1">ab-av1 repo&lt;/a> to raise a PR or issue if you have some ideas.&lt;/p></description></item><item><title>Rust async batching with benjamin-batchly</title><link>https://alexheretic.github.io/posts/benjamin-batchly/</link><pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate><guid>https://alexheretic.github.io/posts/benjamin-batchly/</guid><description>&lt;p>Sometimes instead of doing lots of little things concurrently, it is better to bundle them together
and do them all at once, as a &lt;em>batch&lt;/em>. So on a bank holiday Thursday morning I awoke early (mostly due to the screams of my 1 year old boys) and (after the screaming stopped) wrote a crate to help do that: &lt;a href="https://github.com/alexheretic/benjamin-batchly">benjamin_batchly&lt;/a>.&lt;/p>
&lt;h2 id="example-inserting-into-a-database" >Example: Inserting into a database
&lt;span>
&lt;a href="#example-inserting-into-a-database">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>A recurring theme of database optimisation is reducing &amp;ldquo;trips&amp;rdquo; to the database. It is usually faster to send 1 fat message containing N items than it is to send N thin messages containing just 1 item.&lt;/p>
&lt;p>Consider a crud-style create request which we&amp;rsquo;d like to insert into a database.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">handle_create_foo&lt;/span>(db: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">Db&lt;/span>, data: &lt;span style="color:#a6e22e">CreateFooRequest&lt;/span>) -&amp;gt; Result&lt;span style="color:#f92672">&amp;lt;&lt;/span>(), Error&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> db_item &lt;span style="color:#f92672">=&lt;/span> DbItem::from(data);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db.insert(db_item).&lt;span style="color:#66d9ef">await&lt;/span>&lt;span style="color:#f92672">?&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Ok(())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>So for each &lt;em>CreateFooRequest&lt;/em> we will insert a single item into our db. We can batch these with a &lt;em>BatchMutex&lt;/em>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">use&lt;/span> benjamin_batchly::{BatchMutex, BatchResult};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">handle_create_foo&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> batch_mutex: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">BatchMutex&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>(), DbItem&lt;span style="color:#f92672">&amp;gt;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">Db&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> data: &lt;span style="color:#a6e22e">CreateFooRequest&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) -&amp;gt; Result&lt;span style="color:#f92672">&amp;lt;&lt;/span>(), Error&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> db_item &lt;span style="color:#f92672">=&lt;/span> DbItem::from(data);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">match&lt;/span> batch_mutex.submit((), db_item).&lt;span style="color:#66d9ef">await&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> BatchResult::Work(&lt;span style="color:#66d9ef">mut&lt;/span> batch) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db.bulk_insert(&lt;span style="color:#f92672">&amp;amp;&lt;/span>batch.items).&lt;span style="color:#66d9ef">await&lt;/span>&lt;span style="color:#f92672">?&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> batch.notify_all_done();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Ok(())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> BatchResult::Done(_) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> Ok(()),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> BatchResult::Failed &lt;span style="color:#f92672">=&amp;gt;&lt;/span> Err(Error::BatchFailed),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Submitting to the &lt;em>BatchMutex&lt;/em> provides 3 async outcomes.&lt;/p>
&lt;ul>
&lt;li>&lt;em>&lt;strong>Work&lt;/strong>&lt;/em> A batch of 1 or more items, including the one submitted, which should be handled.&lt;/li>
&lt;li>&lt;em>&lt;strong>Done&lt;/strong>&lt;/em> The submitted item was handled in a batch by another submitter &amp;amp; notified done.&lt;/li>
&lt;li>&lt;em>&lt;strong>Failed&lt;/strong>&lt;/em> The submitted item was handled in a batch by another submitter but dropped before notifying done.&lt;/li>
&lt;/ul>
&lt;p>So if 100 &lt;em>CreateFooRequest&lt;/em> requests come in while a batch is ongoing they&amp;rsquo;ll await at &lt;em>submit&lt;/em>. Once the previous batch has finished all waiting submissions become the next batch. 1 call will return &lt;em>BatchResult::Work&lt;/em> and after the &lt;em>batch.notify_all_done()&lt;/em> call 99 others will return &lt;em>BatchResult::Done&lt;/em>.&lt;/p>
&lt;p>Note: In the example I used the unit type () as the first argument for &lt;em>submit&lt;/em>. This is the &amp;ldquo;batch key&amp;rdquo; which can be used to partition batching. Only items submitted with the same batch key are bundled together which is useful in more general cases.&lt;/p>
&lt;p>Note(2): Individual item return values are also supported, check out the &lt;a href="https://docs.rs/benjamin_batchly/latest/benjamin_batchly">docs&lt;/a> for more info.&lt;/p>
&lt;h2 id="benjamin-batchly-implementation-goals" >benjamin-batchly implementation goals
&lt;span>
&lt;a href="#benjamin-batchly-implementation-goals">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Some I had goals for the implementation:&lt;/p>
&lt;ul>
&lt;li>Avoid spawning any additional tasks.&lt;/li>
&lt;li>Avoid lifetime issues (so probably avoid async closures).&lt;/li>
&lt;/ul>
&lt;p>By using a async return value instead of a closure it&amp;rsquo;s clear who is doing the work here and avoids lifetime borrowing &amp;amp; move issues in the abstraction.&lt;/p>
&lt;ul>
&lt;li>All submissions &lt;strong>must&lt;/strong> know whether the batch worked or not.&lt;/li>
&lt;li>Usage should be as &amp;ldquo;foolproof&amp;rdquo; as possible.&lt;/li>
&lt;/ul>
&lt;p>One of the wonderful Rust concepts that really allows this lib to shine is the &lt;a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">Drop trait&lt;/a>. It eliminates foot guns by reliably providing feedback to submit callers in the edge cases. Love it.&lt;/p>
&lt;ul>
&lt;li>Batching should have minimal latency overhead.&lt;/li>
&lt;/ul>
&lt;p>In my motivating use case I&amp;rsquo;m fine with batch sizes of 1 for low traffic and I didn&amp;rsquo;t want to wait artificially. The currently implementation the batch size is totally driven by how long it takes to do the work and how many new submissions are incoming. So slow processes with high traffic will naturally see bigger batches. Submissions are never waiting around for a batch, if they can go, they go. Maybe in future the crate should also handing some form of configurable waiting, if there&amp;rsquo;s a good use case?&lt;/p></description></item><item><title>AV1 encoding: ab-av1</title><link>https://alexheretic.github.io/posts/ab-av1/</link><pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate><guid>https://alexheretic.github.io/posts/ab-av1/</guid><description>&lt;p>In &lt;a href="https://alexheretic.github.io/posts/av1-p1">my previous post&lt;/a> I looked at video encoding using svt-av1 with &lt;strong>crf&lt;/strong> &amp;amp; &lt;strong>preset&lt;/strong> settings and using VMAF to rate the resultant quality. Av1 encoding is reasonably fast now, but encoding a full video then checking the VMAF potentially multiple times to find a good crf &amp;amp; preset&amp;hellip; that is going to be &lt;em>not so fast&lt;/em>.&lt;/p>
&lt;h2 id="sample-encoding" >Sample encoding
&lt;span>
&lt;a href="#sample-encoding">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>My answer was to cut a small section of the &lt;em>vid.mp4&lt;/em> original video, say 20s long, and encode that. It&amp;rsquo;s obviously much faster encoding a short clip, it&amp;rsquo;s also similarly much faster to measure the VMAF. From the clip we can calculate/guess the size of the fully encoded output too. However, the short clip may not be representative of the full video and produce inaccurate VMAF/size.&lt;/p>
&lt;p>But we can improve the accuracy by taking multiple samples considering all of them. It&amp;rsquo;s still way faster to encode &amp;amp; VMAF a bunch of 20s samples than to do the full video.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>vid.mp4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+--------------------------------------------------------------------------------+
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| |A| |B| |C| |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+--------------------------------------------------------------------------------+
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | | |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v v v
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cut 20s vid.a.mp4 vid.b.mp4 vid.c.mp4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | | |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v v v
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> encode vid.a.av1.mp4 vid.b.av1.mp4 vid.c.av1.mp4
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>Cut &lt;em>vid.mp4&lt;/em> into 3 20s samples spaced throughout the full video (a, b &amp;amp; c). This is done with ffmpeg and is a comparatively instant operation.&lt;/li>
&lt;li>Encode each sample using svt-av1.&lt;/li>
&lt;li>Calculate VMAF score for each sample.&lt;/li>
&lt;/ul>
&lt;p>Then from the samples we can calculate the mean VMAF and size diff. We can use this to predict what the full video size &amp;amp; VMAF would be after a (potentially lengthy) full encode.&lt;/p>
&lt;p>While it&amp;rsquo;s easy enough to cut a sample using ffmpeg the whole process got complicated enough that I wrote a CLI program to help me.&lt;/p>
&lt;h2 id="ab-av1" >ab-av1
&lt;span>
&lt;a href="#ab-av1">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>&lt;strong>ab-av1&lt;/strong> (&lt;a href="https://github.com/alexheretic/ab-av1#readme">github&lt;/a>, &lt;a href="https://aur.archlinux.org/packages/ab-av1">AUR&lt;/a>) is a rust CLI binary that I wrote to handle sample encoding &lt;em>(and more)&lt;/em>. It calls out to ffmpeg &amp;amp; svt-av1 as child processes to do the actual cutting, encoding and VMAFing.&lt;/p>
&lt;p>ab-av1 has functionality split into subcommands. The first one I wrote handles sample encoding.&lt;/p>
&lt;h3 id="ab-av1-sample-encode" >ab-av1 sample-encode
&lt;span>
&lt;a href="#ab-av1-sample-encode">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;blockquote>
&lt;p>Encode short video samples of an input using provided crf &amp;amp; preset. This is much quicker than full encode/vmaf run.&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>ab-av1 sample-encode [OPTIONS] -i &amp;lt;INPUT&amp;gt; --crf &amp;lt;CRF&amp;gt; --preset &amp;lt;PRESET&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Let&amp;rsquo;s give it a bash on the same &lt;em>vid.mp4&lt;/em> we used previously.&lt;/p>
&lt;p>&lt;video src="ab-av1-sample-encode.mp4" poster="ab-av1-sample-encode.avif" width="100%" playsinline controls>&lt;/video>&lt;/p>
&lt;p>So from the 3 samples we can predict VMAF &lt;strong>96.36&lt;/strong> and a &lt;strong>59% encoded size&lt;/strong>. Since already fully encoded this video with these settings we know that real result was VMAF &lt;strong>96.04&lt;/strong> with &lt;strong>66%&lt;/strong> size. So we can see the predictions are indeed approximate. But the big difference is we did our prediction in &lt;strong>19 seconds&lt;/strong> vs ~13 minutes.&lt;/p>
&lt;p>We can always up the sample count if we suspect our video to be more variable. E.g. if I&amp;rsquo;d used 8 samples above it would have taken 47 seconds to predict VMAF &lt;strong>96.04&lt;/strong> with &lt;strong>68%&lt;/strong> size, which is &lt;em>very&lt;/em> close to the truth and still a lot faster than encoding the whole thing.&lt;/p>
&lt;p>With &lt;strong>sample-encode&lt;/strong> we now have a fast &amp;amp; convenient way to how analyse any svt-av1 crf and preset setting. We can now start using it to search for the highest crf that achieves a given VMAF score. Naturally ab-av1 has a subcommand for this.&lt;/p>
&lt;h3 id="ab-av1-crf-search" >ab-av1 crf-search
&lt;span>
&lt;a href="#ab-av1-crf-search">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;blockquote>
&lt;p>Interpolated binary search using sample-encode to find the best crf value delivering &lt;strong>min-vmaf&lt;/strong> &amp;amp; &lt;strong>max-encoded-percent&lt;/strong>.&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>ab-av1 crf-search [OPTIONS] -i &amp;lt;INPUT&amp;gt; --preset &amp;lt;PRESET&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Let&amp;rsquo;s try it out by searching for the best crf for &lt;em>vid.mp4&lt;/em> to get VMAF 94.&lt;/p>
&lt;p>&lt;img src="ab-av1-crf-search.png" alt="">&lt;/p>
&lt;p>The command called sample-encode 4 times as it searched for the highest crf to satisfy our VMAF constraint. It tells us that if we can up our crf to &lt;strong>36&lt;/strong> to get our desired quality. Higher crf means our output is will be even smaller. It also predicts how long the full encode will take, ~6 minutes, which we already know is pretty close to the truth.&lt;/p>
&lt;p>Because sample-encode itself is so fast the entire crf-search took only around a minute. Of course this will slow down with lower presets, but should always be proportionally much quicker than doing a full encode.&lt;/p>
&lt;h2 id="evaluating-svt-av1-presets" >Evaluating svt-av1 presets
&lt;span>
&lt;a href="#evaluating-svt-av1-presets">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>ab-av1 provides a way to take an objective look at svt-av1 presets and to do it in &lt;em>a single human lifetime&lt;/em>. We already know lower presets are higher quality and take longer, but how high and how long?&lt;/p>
&lt;p>Well lower presets are &lt;em>very&lt;/em> slow indeed. It&amp;rsquo;s also true that all presets produce roughly the same size output on a given crf. So we need to get a VMAF score to show the true value.&lt;/p>
&lt;p>&lt;strong>crf-search&lt;/strong> can do this, if the preset gives better quality we should be able to find a higher crf value to satisfy our VMAF constraint.&lt;/p>
&lt;p>&lt;img src="ab-av1-presets.png" alt="" title="For presets under 4 even the sample encodes take forever">&lt;/p>
&lt;p>And indeed this is the case. We can use higher crf values to achieve VMAF 94 as we use lower presets. From this example preset &lt;strong>6&lt;/strong> seems a good compromise between speed and quality.&lt;/p>
&lt;h2 id="ab-av1-extras" >ab-av1: extras
&lt;span>
&lt;a href="#ab-av1-extras">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>&lt;strong>sample-encode&lt;/strong> &amp;amp; &lt;strong>crf-search&lt;/strong> are the &amp;ldquo;guts&amp;rdquo; of ab-av1, but it also comes with some other commands that make use of, or can be used alongside, those. They are at least more ergonomic that using ffmpeg directly and have nice progress bars.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>auto-encode&lt;/strong> &lt;em>Automatically determine the best crf to deliver the min-vmaf and use it to encode a video.&lt;/em>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>ab-av1 auto-encode [OPTIONS] -i &amp;lt;INPUT&amp;gt; --preset &amp;lt;PRESET&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>&lt;strong>encode&lt;/strong> &lt;em>Simple invocation of ffmpeg &amp;amp; SvtAv1EncApp to encode a video.&lt;/em>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>ab-av1 encode [OPTIONS] -i &amp;lt;INPUT&amp;gt; --crf &amp;lt;CRF&amp;gt; --preset &amp;lt;PRESET&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>&lt;strong>vmaf&lt;/strong> &lt;em>Simple full calculation of VMAF score distorted file vs original file.&lt;/em>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>ab-av1 vmaf --original &amp;lt;ORIGINAL&amp;gt; --distorted &amp;lt;DISTORTED&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;p>If you have ideas to improve ab-av1, come on over and raise an issue at &lt;a href="https://github.com/alexheretic/ab-av1">alexheretic/ab-av1&lt;/a>.&lt;/p>
&lt;h2 id="further-reading-av1an" >Further reading: av1an
&lt;span>
&lt;a href="#further-reading-av1an">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>You should also be aware of the more ambitious project &lt;a href="https://github.com/master-of-zen/Av1an">av1an&lt;/a>, it&amp;rsquo;s also a rust CLI wrapper that controls child processes. It also supports encoding to a &amp;ldquo;target-quality&amp;rdquo; VMAF score.&lt;/p>
&lt;p>However, I found it&amp;rsquo;s VMAF analysis to be too slow for my patience, hence my investigation into sample encoding &amp;amp; VMAF. I also find svt-av1 to do good enough threading on its own, so don&amp;rsquo;t benefit too much from the chunk-based concurrent encoding av1an provides &lt;em>(though libaom &amp;amp; other encoders are perhaps a different story)&lt;/em>.&lt;/p></description></item><item><title>AV1 encoding: SVT-AV1 &amp; VMAF</title><link>https://alexheretic.github.io/posts/av1-p1/</link><pubDate>Sun, 06 Feb 2022 00:00:00 +0000</pubDate><guid>https://alexheretic.github.io/posts/av1-p1/</guid><description>&lt;p>I&amp;rsquo;ve been experimenting with av1 video encoding for a while now. Av1 is a royalty free video codec set to replace existing codecs with better quality and/or lower bitrates. Support for it is somewhat decent now. Back when I first tried it I found the encoding speed (using the reference encoder libaom) to be just too slow.&lt;/p>
&lt;p>However, I later read about the &lt;a href="https://gitlab.com/AOMediaCodec/SVT-AV1">svt-av1&lt;/a> encoder over at &lt;a href="https://www.phoronix.com">phoronix&lt;/a> which offers much faster encoding. More recently svt-av1 &lt;strong>v0.9&lt;/strong> has released and &lt;a href="https://www.phoronix.com/scan.php?page=article&amp;amp;item=svt-av1-09&amp;amp;num=1">is even faster&lt;/a>. So I think we&amp;rsquo;re at the point where av1 encoding is now fast enough for mortals like me to actually use.&lt;/p>
&lt;h2 id="re-encoding-h264--friends" >Re-encoding h264 &amp;amp; friends
&lt;span>
&lt;a href="#re-encoding-h264--friends">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>A fair test of a codec is to take a high quality original compare an encoding using av1 and one using h264 (or whatever). However, in reality I have a bunch of already h264-ed videos with no high-quality originals. Av1 in many cases can do a much harder feat in re-encoding h264 to a significantly smaller size without perceptible quality loss.&lt;/p>
&lt;p>Lets re-encode a ~35 minute 854x480 h264 video as an example. First you&amp;rsquo;ll need svt-av1 &amp;amp; ffmpeg installed.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>sudo pacman -Syu svt-av1 ffmpeg
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then we can use them to re-encode &lt;em>vid.mp4&lt;/em>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>ffmpeg -loglevel error -i vid.mp4 -pix_fmt yuv420p10le -strict -1 -f yuv4mpegpipe - &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> | SvtAv1EncApp -i stdin --crf &lt;span style="color:#ae81ff">32&lt;/span> --preset &lt;span style="color:#ae81ff">8&lt;/span> --input-depth &lt;span style="color:#ae81ff">10&lt;/span> -b stdout &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> | ffmpeg -i - -i vid.mp4 -map 0:v -map 1:a:0 -c:a copy -c:v copy vid.av1.mp4
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Here we&amp;rsquo;re doing 3 commands each piping into the next:&lt;/p>
&lt;ul>
&lt;li>Use ffmpeg to convert &lt;em>vid.mp4&lt;/em> into a format that svt-av1 can encode &lt;em>(using 10-bit over 8-bit as it&amp;rsquo;s generally recommended)&lt;/em>.&lt;/li>
&lt;li>Use svt-av1 to encode the stream using a &lt;strong>crf&lt;/strong> (quality) and &lt;strong>preset&lt;/strong> (encoder speed) setting we just made up.&lt;/li>
&lt;li>Finally use ffmpeg again to take the av1 data stream and combine with the original audio into a new &lt;em>vid.av1.mp4&lt;/em> file.&lt;/li>
&lt;/ul>
&lt;p>On my 5800x this takes &lt;strong>~7 minutes&lt;/strong>, so pretty fast, and encodes down to &lt;strong>66% original size&lt;/strong>. When I look at both side by side they seem the same quality. That&amp;rsquo;s great! &amp;hellip;But I wonder if we can do better.&lt;/p>
&lt;p>The most important settings above are the &lt;strong>crf&lt;/strong> &amp;amp; &lt;strong>preset&lt;/strong>.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>preset&lt;/strong> (0-13) is how fast the encoder works, higher values mean faster encodes but with lower quality.&lt;/li>
&lt;li>&lt;strong>crf&lt;/strong> is &amp;ldquo;constant rate factor&amp;rdquo; (1-63), higher values mean lower quality &amp;amp; lower size.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>preset&lt;/strong> values seem to work pretty consistently across all videos. You can pick a preset based on how impatient you are. My rough guide would be pick &lt;strong>6&lt;/strong> if &lt;strong>4&lt;/strong> is too slow for you, &lt;strong>8&lt;/strong> if &lt;strong>6&lt;/strong> is.&lt;/p>
&lt;p>&lt;strong>crf&lt;/strong> is trickier. The &amp;ldquo;right&amp;rdquo; setting will be different for how high quality you want, obviously, but it&amp;rsquo;s also different video to video, particularly across video resolutions.&lt;/p>
&lt;p>If we have time we can try more crf (and preset) values and check if the quality is good enough. But it&amp;rsquo;s slow, boring and inconsistent to compare videos manually with my actual eyes. It would be nice if we had a way to check the quality of the result eyelessly.&lt;/p>
&lt;h2 id="vmaf" >VMAF
&lt;span>
&lt;a href="#vmaf">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>VMAF is a video quality metric we can use to do that. You give it two videos and it&amp;rsquo;ll give you a score (0-100) of how close the distorted was to the original, 100 being perfect.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>sudo pacman -Syu vmaf
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We can use this (via ffmpeg) to test our &lt;em>vid.av1.mp4&lt;/em>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>ffmpeg -i vid.av1.mp4 -i vid.mp4 -lavfi libvmaf -f null -
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This produces a VMAF score of &lt;strong>96.044922&lt;/strong>. So supports what my eyes thought &lt;em>vid.av1.mp4&lt;/em> is very similar to the h264 &lt;em>vid.mp4&lt;/em>. It also suggests we could get the av1 version even smaller and achieve, say, VMAF 95.&lt;/p>
&lt;p>Now we have the tools to test different &lt;strong>crf&lt;/strong> values to find the highest that gives us a given VMAF score. We can try different &lt;strong>preset&lt;/strong> values too.&lt;/p>
&lt;p>The catch is VMAF itself isn&amp;rsquo;t super fast. The run above took ~6 minutes using all my cores. So testing another crf will take another 13 minutes or so. If we try lower presets it&amp;rsquo;ll take longer to encode. And of course this is with a shortish low resolution video, longer 1080p or 4k videos will take ages.&lt;/p>
&lt;p>In the next post I&amp;rsquo;ll talk about a way to get &lt;strong>much faster VMAF scores&lt;/strong> for any given svt-av1 crf &amp;amp; preset.&lt;/p></description></item><item><title>Game years</title><link>https://alexheretic.github.io/posts/games/</link><pubDate>Sat, 05 Feb 2022 00:00:00 +0000</pubDate><guid>https://alexheretic.github.io/posts/games/</guid><description>&lt;p>In 2017 I quit my job to make a PC programming puzzle game &lt;a href="https://www.roboinstruct.us">&lt;strong>Robo Instructus&lt;/strong>&lt;/a>.&lt;/p>
&lt;p>&lt;img src="steam-robo-instructus.webp" alt="">&lt;/p>
&lt;p>One aspect in particular I worked on in some depth was &lt;strong>text rendering&lt;/strong>. Robo Instructus has a lot of text &amp;amp; there just wasn&amp;rsquo;t the libraries in the Rust ecosystem that could perform as I needed, particularly compiled in debug mode &lt;em>(and I&amp;rsquo;m not waiting for rust &amp;ndash;release compiles after each code change!)&lt;/em>.&lt;/p>
&lt;p>So I took over maintenance of &lt;a href="https://gitlab.redox-os.org/redox-os/rusttype">rusttype&lt;/a> and fixed my issues with it &amp;amp; its &amp;ldquo;gpu cache&amp;rdquo; module. I eventually rewrote it as &lt;a href="https://github.com/alexheretic/ab-glyph">ab-glyph&lt;/a>. With that as a base I also wrote the &lt;a href="https://github.com/alexheretic/glyph-brush">glyph-brush&lt;/a> crates which handle layout, clever caching and optimise the process of getting text strings into vertices pointing a subtextures on your GPU.&lt;/p>
&lt;p>My open source libs allowed me to handle the profusion of text in my game, I&amp;rsquo;ve also seen them used in other rust game projects &amp;amp; engines which is nice! However, text rendering is surprisingly deep &amp;amp; complex so I&amp;rsquo;ve no doubt superior tools will appear in the rust ecosystem in time.&lt;/p>
&lt;p>I wrote about some of my text rendering adventures on the game blog:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://blog.roboinstruct.us/2018/05/18/technical-look-at-text-rendering-in-robo-instructus.html">2018: Technical Look At Text Rendering In Robo Instructus&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.roboinstruct.us/2018/05/25/technical-look-at-text-rendering-in-robo-instructus-ii.html">2018: Faster Screen Text Rendering&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.roboinstruct.us/2020/05/24/the-otf-journey.html">2020: Otf Font Rendering or: How I Should Have Learned To Stop Worrying And Love The Ttf&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://blog.roboinstruct.us/2020/05/24/the-otf-journey.html">&lt;img src="https://blog.roboinstruct.us/assets/2020-05-23/q-c-beziers.png" alt="">&lt;/a>&lt;/p>
&lt;p>You can read more over at &lt;a href="https://blog.roboinstruct.us">blog.roboinstruct.us&lt;/a>.&lt;/p></description></item></channel></rss>